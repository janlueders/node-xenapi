// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, VLANCollection, _, debug, minimatch,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  debug = require('debug')('XenAPI:VLANCollection');

  Promise = require('bluebird');

  minimatch = require('minimatch');

  _ = require('lodash');

  VLANCollection = (function() {
    var VLAN, createVLANInstance, session, xenAPI;

    VLAN = void 0;

    session = void 0;

    xenAPI = void 0;

    createVLANInstance = function(VLAN, opaqueRef) {
      return new VLAN(session, VLAN, opaqueRef, xenAPI);
    };


    /**
    * Construct VLANCollection
    * @class
    * @param      {Object}   session - An instance of Session
    * @param      {Object}   VLAN - Dependency injection of the VLAN class.
    * @param      {Object}   xenAPI - An instance of XenAPI
     */

    function VLANCollection(_session, _VLAN, _xenAPI) {
      this.findOpaqueRef = bind(this.findOpaqueRef, this);
      this.create = bind(this.create, this);
      this.list = bind(this.list, this);
      debug("constructor()");
      if (!_session) {
        throw Error("Must provide session");
      }
      if (!_VLAN) {
        throw Error("Must provide VLAN");
      }
      if (!_xenAPI) {
        throw Error("Must provide xenAPI");
      }
      session = _session;
      xenAPI = _xenAPI;
      VLAN = _VLAN;
    }


    /**
    * List all VLANs
    * @return     {Promise}
     */

    VLANCollection.prototype.list = function() {
      debug("list()");
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return session.request("VLAN.get_all_records").then(function(value) {
            var VLANs;
            if (!value) {
              reject();
            }
            debug("Received " + (Object.keys(value).length) + " records");
            VLANs = _.map(value, createVLANInstance);
            return resolve(_.filter(VLANs, function(VLAN) {
              return VLAN;
            }));
          })["catch"](function(e) {
            debug(e);
            return reject(e);
          });
        };
      })(this));
    };

    VLANCollection.prototype.create = function(network, vm, mac) {
      debug("create()");
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var newVLAN, VLAN;
          if (!mac) {
            mac = "";
          }
          VLAN = {
            uuid: null,
            device: vm.VLANs.length.toString(),
            MAC: mac,
            MTU: "1500",
            currently_attached: false,
            network: network.opaqueRef,
            VM: vm.opaqueRef
          };
          newVLAN = new VLAN(session, VLAN, "OpaqueRef:NULL", xenAPI);
          return resolve(newVLAN);
        };
      })(this));
    };

    VLANCollection.prototype.findOpaqueRef = function(opaqueRef) {
      debug("findOpaqueRef(" + opaqueRef + ")");
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return session.request("VLAN.get_record", [opaqueRef]).then(function(value) {
            var VLAN;
            if (!value) {
              reject();
            }
            VLAN = createVLANInstance(value, opaqueRef);
            return resolve(VLAN);
          })["catch"](function(e) {
            debug(e);
            return reject(e);
          });
        };
      })(this));
    };

    return VLANCollection;

  })();

  module.exports = VLANCollection;

}).call(this);
